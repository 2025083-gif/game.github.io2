<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Stickman Battle Evolution</title>
    <style>
        body { background: #1a1a1a; color: white; font-family: 'Arial', sans-serif; overflow: hidden; display: flex; flex-direction: column; align-items: center; }
        canvas { background: #333; border-bottom: 5px solid #555; box-shadow: 0 10px 30px rgba(0,0,0,0.5); }
        .stats { display: flex; gap: 20px; margin: 10px; font-size: 18px; font-weight: bold; }
        #upgradeMenu { 
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9); padding: 30px; border: 2px solid gold; border-radius: 10px;
            display: none; text-align: center; z-index: 10;
        }
        .btn { 
            display: block; width: 200px; padding: 10px; margin: 10px auto; 
            background: #444; color: white; border: 1px solid #fff; cursor: pointer;
        }
        .btn:hover { background: gold; color: black; }
        .msg { color: #aaa; font-size: 14px; }
    </style>
</head>
<body>

    <div class="stats">
        <span>Stage: <span id="uiStage">1</span></span>
        <span>Level: <span id="uiLevel">1</span></span>
        <span>HP: <span id="uiHP">100/100</span></span>
    </div>

    <canvas id="gameCanvas" width="800" height="400"></canvas>

    <div id="upgradeMenu">
        <h2>LEVEL UP!</h2>
        <p>能力を選択してください</p>
        <button class="btn" onclick="upgrade('atk')">攻撃力 UP (+5)</button>
        <button class="btn" onclick="upgrade('spd')">移動速度 UP (+1)</button>
        <button class="btn" onclick="upgrade('hp')">最大HP UP (+20)</button>
        <button class="btn" onclick="upgrade('rng')">攻撃リーチ UP (+5)</button>
    </div>

    <div class="msg">A / D: 移動 | SPACE: 攻撃</div>

<script>
/** @type {HTMLCanvasElement} */
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");

// ゲーム状態
let stage = 1;
let level = 1;
let gameActive = true;
let frame = 0;

// キャラクター定義
const p = {
    x: 100, y: 300, w: 40, h: 80,
    hp: 100, maxHp: 100, atk: 15, speed: 5, range: 60,
    color: "#00d4ff", dir: 1, isAttacking: 0, moveFrame: 0
};

const e = {
    x: 600, y: 300, w: 40, h: 80,
    hp: 50, maxHp: 50, atk: 5, speed: 2, range: 50,
    color: "#ff4d4d", dir: -1, isAttacking: 0, moveFrame: 0,
    aiCooldown: 0
};

const particles = [];

// キー入力
const keys = {};
window.onkeydown = (ev) => {
    keys[ev.code] = true;
    if (ev.code === "Space" && p.isAttacking === 0) p.isAttacking = 15;
};
window.onkeyup = (ev) => keys[ev.code] = false;

function drawStickman(char, isMoving) {
    const {x, y, dir, isAttacking, color} = char;
    const groundY = y + 80;
    ctx.strokeStyle = color;
    ctx.lineWidth = 4;
    ctx.lineCap = "round";

    // 動きのアニメーション計算
    const walkAnim = Math.sin(frame * 0.2) * 15;
    const attackAnim = isAttacking > 0 ? (15 - isAttacking) * 3 : 0;

    ctx.beginPath();
    // 体 (中心)
    ctx.moveTo(x, groundY - 40);
    ctx.lineTo(x, groundY - 70);
    // 頭
    ctx.arc(x, groundY - 80, 10, 0, Math.PI * 2);
    // 足
    ctx.moveTo(x, groundY - 40);
    ctx.lineTo(x + (isMoving ? walkAnim : -5), groundY); // 左足
    ctx.moveTo(x, groundY - 40);
    ctx.lineTo(x + (isMoving ? -walkAnim : 5), groundY); // 右足
    // 腕
    ctx.moveTo(x, groundY - 65);
    if (isAttacking > 0) {
        ctx.lineTo(x + (40 + attackAnim) * dir, groundY - 60); // 攻撃モーション
    } else {
        ctx.lineTo(x + 15 * dir, groundY - 45); // 通常
    }
    ctx.stroke();

    // 攻撃エフェクト
    if (isAttacking > 5) {
        ctx.strokeStyle = "rgba(255,255,255,0.5)";
        ctx.beginPath();
        ctx.arc(x, groundY - 60, char.range, -0.5, 0.5);
        ctx.stroke();
    }
}

function update() {
    if (!gameActive) return;
    frame++;

    // プレイヤー移動
    let moving = false;
    if (keys["KeyA"]) { p.x -= p.speed; p.dir = -1; moving = true; }
    if (keys["KeyD"]) { p.x += p.speed; p.dir = 1; moving = true; }
    p.x = Math.max(0, Math.min(canvas.width, p.x));

    if (p.isAttacking > 0) {
        if (p.isAttacking === 8) checkHit(p, e);
        p.isAttacking--;
    }

    // 敵のAI
    const dist = p.x - e.x;
    e.dir = dist > 0 ? 1 : -1;
    if (Math.abs(dist) > e.range - 10) {
        e.x += e.dir * e.speed;
    } else if (e.aiCooldown <= 0) {
        e.isAttacking = 15;
        e.aiCooldown = 40 + Math.random() * 30;
    }
    
    if (e.isAttacking > 0) {
        if (e.isAttacking === 8) checkHit(e, p);
        e.isAttacking--;
    }
    if (e.aiCooldown > 0) e.aiCooldown--;

    draw();
    requestAnimationFrame(update);
}

function checkHit(attacker, target) {
    const dist = Math.abs(attacker.x - target.x);
    if (dist < attacker.range) {
        target.hp -= attacker.atk;
        // 火花
        for(let i=0; i<5; i++) particles.push({x: target.x, y: 330, vx: (Math.random()-0.5)*10, vy: -Math.random()*5, life: 20});
        
        if (target.hp <= 0) {
            if (target === e) victory();
            else gameOver();
        }
    }
}

function victory() {
    gameActive = false;
    level++;
    stage++;
    document.getElementById("upgradeMenu").style.display = "block";
}

function upgrade(type) {
    if (type === 'atk') p.atk += 5;
    if (type === 'spd') p.speed += 1;
    if (type === 'hp') { p.maxHp += 20; p.hp = p.maxHp; }
    if (type === 'rng') p.range += 5;

    // 次の敵を生成
    e.maxHp = 40 + stage * 15;
    e.hp = e.maxHp;
    e.atk = 5 + stage * 3;
    e.speed = 1.5 + (stage * 0.3);
    e.x = 700;
    p.x = 100;
    
    document.getElementById("uiLevel").innerText = level;
    document.getElementById("uiStage").innerText = stage;
    document.getElementById("upgradeMenu").style.display = "none";
    gameActive = true;
    update();
}

function gameOver() {
    alert("敗北しました。Stage: " + stage);
    location.reload();
}

function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // 地面
    ctx.fillStyle = "#444";
    ctx.fillRect(0, 380, canvas.width, 20);

    // キャラ
    drawStickman(p, keys["KeyA"] || keys["KeyD"]);
    drawStickman(e, true);

    // HPバー描画
    drawBar(p.x - 40, 250, p.hp / p.maxHp, "#00d4ff");
    drawBar(e.x - 40, 250, e.hp / e.maxHp, "#ff4d4d");

    // UI更新
    document.getElementById("uiHP").innerText = `${Math.ceil(p.hp)} / ${p.maxHp}`;

    // パーティクル
    ctx.fillStyle = "yellow";
    particles.forEach((pt, i) => {
        pt.x += pt.vx; pt.y += pt.vy; pt.life--;
        ctx.fillRect(pt.x, pt.y, 3, 3);
        if(pt.life <= 0) particles.splice(i, 1);
    });
}

function drawBar(x, y, pct, color) {
    ctx.fillStyle = "#222";
    ctx.fillRect(x, y, 80, 10);
    ctx.fillStyle = color;
    ctx.fillRect(x, y, 80 * Math.max(0, pct), 10);
}

// 初回起動
update();

</script>
</body>
</html>
